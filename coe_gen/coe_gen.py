import argparse
import sys
import os

def create_coe_file(input_file, output_file, depth):
    """
    Reads 32-bit hex instructions from input_file, pads with zeros
    up to the specified depth, and writes a Vivado-compatible .coe file
    to output_file.
    """
    instructions = []
    line_num = 0

    print(f"Reading instructions from: {input_file}")

    # --- Read and process input file ---
    try:
        with open(input_file, 'r') as f_in:
            for line in f_in:
                line_num += 1
                # Clean up the line
                hex_str = line.strip()

                # Skip empty lines or comments (optional, using ';' or '#')
                if not hex_str or hex_str.startswith(';') or hex_str.startswith('#'):
                    continue

                # Validate: Ensure it's a valid hex string
                try:
                    # Convert to int to check validity, but store as string
                    int_val = int(hex_str, 16)
                except ValueError:
                    print(f"Error: Invalid hexadecimal value '{hex_str}' on line {line_num} in {input_file}. Skipping.", file=sys.stderr)
                    continue # Skip this line

                # Validate: Ensure it fits within 32 bits (max 8 hex digits)
                if len(hex_str) > 8:
                    print(f"Error: Hex value '{hex_str}' on line {line_num} exceeds 32 bits (8 hex digits). Skipping.", file=sys.stderr)
                    continue # Skip this line

                # Pad with leading zeros to ensure exactly 8 hex digits and store
                padded_hex = hex_str.upper().zfill(8)
                instructions.append(padded_hex)

    except FileNotFoundError:
        print(f"Error: Input file not found: {input_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading input file {input_file}: {e}", file=sys.stderr)
        sys.exit(1)

    num_instructions = len(instructions)
    print(f"Read {num_instructions} valid instructions.")

    # --- Validate depth vs number of instructions ---
    if num_instructions > depth:
        print(f"Error: Number of instructions ({num_instructions}) exceeds specified BRAM depth ({depth}).", file=sys.stderr)
        sys.exit(1)

    # --- Prepare the full memory vector with padding ---
    output_vector = instructions
    padding_count = depth - num_instructions
    if padding_count > 0:
        print(f"Padding with {padding_count} zero entries ('00000000').")
        output_vector.extend(['00000000'] * padding_count)

    # --- Write the output COE file ---
    print(f"Generating COE file: {output_file}")
    try:
        with open(output_file, 'w') as f_out:
            f_out.write("; COE File Generated by Python Script\n")
            f_out.write(f"; Source File: {os.path.basename(input_file)}\n")
            f_out.write(f"; BRAM Depth: {depth}\n")
            f_out.write("MEMORY_INITIALIZATION_RADIX = 16;\n")
            f_out.write("MEMORY_INITIALIZATION_VECTOR =\n")

            if not output_vector:
                # Handle case where depth is 0 or no instructions and no padding
                f_out.write(";\n")
            else:
                # Write each entry, handling comma/semicolon correctly
                for i, val in enumerate(output_vector):
                    if i == len(output_vector) - 1:
                        f_out.write(f"{val};\n")  # Last entry ends with semicolon
                    else:
                        f_out.write(f"{val},\n")   # Other entries end with comma

        print(f"Successfully generated COE file: {output_file}")

    except IOError as e:
        print(f"Error writing output file {output_file}: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred during file writing: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate a Xilinx COE file for BRAM initialization from a hex instruction file."
    )
    parser.add_argument(
        "input_file",
        help="Path to the input text file containing 32-bit hex instructions (one per line)."
    )
    parser.add_argument(
        "output_file",
        help="Path for the output COE file to be generated."
    )
    parser.add_argument(
        "-d", "--depth",
        type=int,
        required=True,
        help="Total desired depth (number of locations) for the BRAM."
    )

    args = parser.parse_args()

    if args.depth < 0:
        print("Error: BRAM depth cannot be negative.", file=sys.stderr)
        sys.exit(1)

    create_coe_file(args.input_file, args.output_file, args.depth)